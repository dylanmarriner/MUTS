"""
BaseExploiter - Shared foundation for all ECU exploitation modules.
Provides common security validation, error handling, logging, and communication patterns.
All exploiter modules inherit from this base to ensure consistency and safety.
"""

import asyncio
import logging
import time
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
import traceback

from models import (
    SecurityLevel, SecurityCredentials, LogEntry, FlashOperation,
    FlashState, CANMessage, OBDPacket, ExploiterState
)
from mazda_security_core import MazdaSecurityCore
from mazda_memory_map import MazdaMemoryMap, MemoryRange


class ExploiterError(Exception):
    """Base class for exploiter errors."""
    pass


class SecurityViolationError(ExploiterError):
    """Security policy violation."""
    pass


class CommunicationError(ExploiterError):
    """Communication failure."""
    pass


class OperationError(ExploiterError):
    """Operation execution failure."""
    pass


@dataclass
class OperationResult:
    """Result of an exploiter operation."""
    success: bool
    operation_id: str
    data: Optional[Any] = None
    error_message: Optional[str] = None
    execution_time: float = 0.0
    warnings: List[str] = field(default_factory=list)
    
    def add_warning(self, warning: str) -> None:
        """Add warning to result."""
        self.warnings.append(warning)
    
    def __bool__(self) -> bool:
        """Boolean conversion based on success."""
        return self.success


@dataclass
class ExploiterConfig:
    """Configuration for exploiter modules."""
    max_retries: int = 3
    timeout_seconds: float = 5.0
    require_backup: bool = True
    validate_checksums: bool = True
    enable_logging: bool = True
    security_enforcement: bool = True
    
    # Performance tuning
    chunk_size: int = 1024  # Bytes per operation
    parallel_operations: int = 1
    
    # Safety limits
    max_operation_time: float = 300.0  # 5 minutes
    max_memory_usage: int = 100 * 1024 * 1024  # 100MB


class BaseExploiter(ABC):
    """
    Base class for all ECU exploitation modules.
    Provides shared functionality for security, communication, error handling, and logging.
    """
    
    def __init__(self, name: str, config: Optional[ExploiterConfig] = None,
                 security_core: Optional[MazdaSecurityCore] = None):
        """
        Initialize base exploiter.
        
        Args:
            name: Exploiter module name
            config: Configuration options
            security_core: Shared security core instance
        """
        self.name = name
        self.config = config or ExploiterConfig()
        self.logger = logging.getLogger(f"{__name__}.{name}")
        
        # State management
        self.state = ExploiterState.IDLE
        self.current_credentials: Optional[SecurityCredentials] = None
        self.operation_count = 0
        
        # Security and validation (use injected instance or create new)
        self.security_core = security_core or MazdaSecurityCore()
        self.memory_map = MazdaMemoryMap()
        
        # Communication interfaces (to be injected)
        self.obd_service = None
        self.can_engine = None
        
        # Statistics
        self.stats = {
            "total_operations": 0,
            "successful_operations": 0,
            "failed_operations": 0,
            "security_violations": 0,
            "total_execution_time": 0.0,
            "average_execution_time": 0.0,
        }
        
        # Operation tracking
        self.active_operations: Dict[str, Dict[str, Any]] = {}
        
        self.logger.info(f"{name} exploiter initialized")
    
    def set_obd_service(self, obd_service) -> None:
        """Set OBD service interface."""
        self.obd_service = obd_service
        self.logger.info("OBD service interface set")
    
    def set_can_engine(self, can_engine) -> None:
        """Set CAN engine interface."""
        self.can_engine = can_engine
        self.logger.info("CAN engine interface set")
    
    def set_credentials(self, credentials: SecurityCredentials) -> None:
        """
        Set security credentials for operations.
        
        Args:
            credentials: Security credentials
        """
        if not self.security_core.validate_session(credentials.session_token):
            raise SecurityViolationError("Invalid or expired credentials")
        
        self.current_credentials = credentials
        self.logger.info(f"Credentials set for user: {credentials.username}")
    
    async def initialize(self) -> OperationResult:
        """
        Initialize the exploiter module.
        
        Returns:
            OperationResult indicating success/failure
        """
        if self.state != ExploiterState.IDLE:
            return OperationResult(
                success=False,
                operation_id="init",
                error_message=f"Cannot initialize, current state: {self.state.value}"
            )
        
        start_time = time.time()
        operation_id = f"{self.name}_init_{int(start_time)}"
        
        try:
            self.state = ExploiterState.INITIALIZING
            
            # Validate interfaces are set
            if not self.obd_service:
                raise CommunicationError("OBD service not set")
            
            if not self.can_engine:
                raise CommunicationError("CAN engine not set")
            
            # Perform module-specific initialization
            await self._on_initialize()
            
            self.state = ExploiterState.CONNECTED
            execution_time = time.time() - start_time
            
            self._log_operation("initialize", operation_id, True, execution_time)
            
            return OperationResult(
                success=True,
                operation_id=operation_id,
                execution_time=execution_time
            )
            
        except Exception as e:
            self.state = ExploiterState.ERROR
            execution_time = time.time() - start_time
            error_msg = f"Initialization failed: {e}"
            
            self._log_operation("initialize", operation_id, False, execution_time, error_msg)
            
            return OperationResult(
                success=False,
                operation_id=operation_id,
                error_message=error_msg,
                execution_time=execution_time
            )
    
    async def shutdown(self) -> OperationResult:
        """
        Shutdown the exploiter module.
        
        Returns:
            OperationResult indicating success/failure
        """
        start_time = time.time()
        operation_id = f"{self.name}_shutdown_{int(start_time)}"
        
        try:
            # Perform module-specific cleanup
            await self._on_shutdown()
            
            self.state = ExploiterState.SHUTDOWN
            execution_time = time.time() - start_time
            
            self._log_operation("shutdown", operation_id, True, execution_time)
            
            return OperationResult(
                success=True,
                operation_id=operation_id,
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            error_msg = f"Shutdown failed: {e}"
            
            self._log_operation("shutdown", operation_id, False, execution_time, error_msg)
            
            return OperationResult(
                success=False,
                operation_id=operation_id,
                error_message=error_msg,
                execution_time=execution_time
            )
    
    @abstractmethod
    async def _on_initialize(self) -> None:
        """Module-specific initialization logic."""
        pass
    
    @abstractmethod
    async def _on_shutdown(self) -> None:
        """Module-specific shutdown logic."""
        pass
    
    def _validate_security(self, required_level: SecurityLevel, 
                          operation: str) -> None:
        """
        Validate security credentials for operation.
        
        Args:
            required_level: Minimum security level required
            operation: Operation description
            
        Raises:
            SecurityViolationError: If not authorized
        """
        if self.config.security_enforcement:
            self.security_core.authorize_operation(
                self.current_credentials, required_level, operation
            )
    
    def _validate_memory_access(self, address: int, size: int, 
                               write_access: bool = False) -> None:
        """
        Validate memory access permissions.
        
        Args:
            address: Starting address
            size: Size of access
            write_access: Whether this is a write operation
            
        Raises:
            SecurityViolationError: If access not permitted
        """
        if not self.memory_map.validate_access(
            address, size, 
            self.current_credentials.security_level if self.current_credentials else SecurityLevel.NONE,
            write_access
        ):
            raise SecurityViolationError(
                f"Memory access not permitted: 0x{address:06X}+{size} "
                f"({'write' if write_access else 'read'})"
            )
    
    async def _execute_with_retry(self, operation: Callable, 
                                 operation_name: str,
                                 *args, **kwargs) -> OperationResult:
        """
        Execute operation with retry logic.
        
        Args:
            operation: Function to execute
            operation_name: Name for logging
            *args: Arguments to pass to operation
            **kwargs: Keyword arguments to pass to operation
            
        Returns:
            OperationResult
        """
        start_time = time.time()
        operation_id = f"{self.name}_{operation_name}_{int(start_time)}"
        
        self.operation_count += 1
        self.active_operations[operation_id] = {
            "name": operation_name,
            "start_time": start_time,
            "args": args,
            "kwargs": kwargs,
        }
        
        last_exception = None
        
        for attempt in range(self.config.max_retries):
            try:
                # Check timeout
                if time.time() - start_time > self.config.max_operation_time:
                    raise OperationError(f"Operation timeout after {self.config.max_operation_time}s")
                
                # Execute operation
                if asyncio.iscoroutinefunction(operation):
                    result = await asyncio.wait_for(
                        operation(*args, **kwargs),
                        timeout=self.config.timeout_seconds
                    )
                else:
                    result = operation(*args, **kwargs)
                
                execution_time = time.time() - start_time
                
                # Update statistics
                self.stats["total_operations"] += 1
                self.stats["successful_operations"] += 1
                self.stats["total_execution_time"] += execution_time
                self.stats["average_execution_time"] = (
                    self.stats["total_execution_time"] / self.stats["total_operations"]
                )
                
                self._log_operation(operation_name, operation_id, True, execution_time)
                
                # Clean up operation tracking
                if operation_id in self.active_operations:
                    del self.active_operations[operation_id]
                
                return OperationResult(
                    success=True,
                    operation_id=operation_id,
                    data=result,
                    execution_time=execution_time
                )
                
            except asyncio.TimeoutError:
                last_exception = OperationError(f"Operation timeout on attempt {attempt + 1}")
                self.logger.warning(f"Operation timeout on attempt {attempt + 1}: {operation_name}")
                
            except Exception as e:
                last_exception = e
                self.logger.warning(f"Operation failed on attempt {attempt + 1}: {operation_name} - {e}")
                
                # Check if we should retry
                if attempt < self.config.max_retries - 1:
                    await asyncio.sleep(0.1 * (attempt + 1))  # Exponential backoff
        
        # All retries failed
        execution_time = time.time() - start_time
        error_msg = f"Operation failed after {self.config.max_retries} attempts: {last_exception}"
        
        # Update statistics
        self.stats["total_operations"] += 1
        self.stats["failed_operations"] += 1
        
        self._log_operation(operation_name, operation_id, False, execution_time, error_msg)
        
        # Clean up operation tracking
        if operation_id in self.active_operations:
            del self.active_operations[operation_id]
        
        return OperationResult(
            success=False,
            operation_id=operation_id,
            error_message=error_msg,
            execution_time=execution_time
        )
    
    async def _send_obd_command(self, mode, pid: str = "", 
                               data: Optional[bytes] = None) -> OBDPacket:
        """
        Send OBD command with error handling.
        
        Args:
            mode: OBD command mode
            pid: Parameter ID
            data: Additional data
            
        Returns:
            OBD packet response
        """
        if not self.obd_service:
            raise CommunicationError("OBD service not available")
        
        try:
            return await self.obd_service.send_command(
                mode, pid, data, self.current_credentials
            )
        except Exception as e:
            raise CommunicationError(f"OBD command failed: {e}")
    
    async def _send_can_message(self, message: CANMessage) -> bool:
        """
        Send CAN message with error handling.
        
        Args:
            message: CAN message to send
            
        Returns:
            True if sent successfully
        """
        if not self.can_engine:
            raise CommunicationError("CAN engine not available")
        
        try:
            return await self.can_engine.send_message(message, self.current_credentials)
        except Exception as e:
            raise CommunicationError(f"CAN message failed: {e}")
    
    def _log_operation(self, operation: str, operation_id: str, 
                      success: bool, execution_time: float,
                      error_message: Optional[str] = None) -> None:
        """
        Log operation execution.
        
        Args:
            operation: Operation name
            operation_id: Unique operation identifier
            success: Whether operation succeeded
            execution_time: Time taken in seconds
            error_message: Error message if failed
        """
        level = "INFO" if success else "ERROR"
        message = f"Operation {operation} {'completed' if success else 'failed'} in {execution_time:.3f}s"
        
        if error_message:
            message += f": {error_message}"
        
        if self.config.enable_logging:
            log_entry = LogEntry(
                level=level,
                module=self.name,
                message=message,
                data={
                    "operation_id": operation_id,
                    "execution_time": execution_time,
                    "success": success,
                }
            )
            
            # Add to security core log
            self.security_core.access_log.append(log_entry)
        
        # Log to standard logger
        if success:
            self.logger.info(message)
        else:
            self.logger.error(message)
    
    def _create_flash_operation(self, operation_id: str) -> FlashOperation:
        """
        Create flash operation tracking object.
        
        Args:
            operation_id: Unique operation identifier
            
        Returns:
            FlashOperation object
        """
        return FlashOperation(
            operation_id=operation_id,
            state=FlashState.IDLE
        )
    
    def _update_flash_operation(self, operation: FlashOperation, 
                               state: FlashState,
                               progress: Optional[float] = None,
                               error_message: Optional[str] = None) -> None:
        """
        Update flash operation progress.
        
        Args:
            operation: Flash operation to update
            state: New state
            progress: Progress percentage (0-1)
            error_message: Error message if applicable
        """
        operation.state = state
        if progress is not None:
            operation.progress = progress
        if error_message:
            operation.error_message = error_message
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get exploiter statistics."""
        return {
            **self.stats,
            "state": self.state.value,
            "operation_count": self.operation_count,
            "active_operations": len(self.active_operations),
            "success_rate": (
                self.stats["successful_operations"] / max(self.stats["total_operations"], 1) * 100
            ),
        }
    
    def get_active_operations(self) -> List[str]:
        """Get list of active operation IDs."""
        return list(self.active_operations.keys())
    
    def reset_statistics(self) -> None:
        """Reset all statistics."""
        self.stats = {
            "total_operations": 0,
            "successful_operations": 0,
            "failed_operations": 0,
            "security_violations": 0,
            "total_execution_time": 0.0,
            "average_execution_time": 0.0,
        }
        self.operation_count = 0
    
    async def validate_system_state(self) -> OperationResult:
        """
        Validate overall system state and interfaces.
        
        Returns:
            OperationResult with validation status
        """
        start_time = time.time()
        operation_id = f"{self.name}_validate_{int(start_time)}"
        
        try:
            # Check interfaces
            if not self.obd_service:
                raise CommunicationError("OBD service not connected")
            
            if not self.can_engine:
                raise CommunicationError("CAN engine not connected")
            
            # Check credentials
            if not self.current_credentials:
                raise SecurityViolationError("No credentials set")
            
            if self.current_credentials.is_expired():
                raise SecurityViolationError("Credentials expired")
            
            # Check state
            if self.state == ExploiterState.ERROR:
                raise OperationError("Exploiter in error state")
            
            execution_time = time.time() - start_time
            
            return OperationResult(
                success=True,
                operation_id=operation_id,
                data={"state": self.state.value, "interfaces": "OK"},
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            error_msg = f"System validation failed: {e}"
            
            return OperationResult(
                success=False,
                operation_id=operation_id,
                error_message=error_msg,
                execution_time=execution_time
            )
    
    def __del__(self):
        """Cleanup on deletion."""
        if self.state != ExploiterState.SHUTDOWN:
            self.logger.warning(f"{self.name} exploiter deleted while not properly shutdown")
