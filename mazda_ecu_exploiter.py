"""
MazdaECUExploiter - Main ECU interface and exploitation coordinator.
Provides high-level ECU operations, coordinates all sub-exploiters, and manages
flash operations, diagnostics, and tuning functions for 2011 Mazdaspeed 3.
"""

import asyncio
import struct
import time
import json
from typing import Dict, List, Optional, Tuple, Any, Union, BinaryIO
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path

from models import (
    SecurityLevel, SecurityCredentials, FlashOperation, FlashState,
    LogEntry, CANMessage, OBDPacket, TelemetryData, DiagnosticTroubleCode,
    TuningParameter, TuningProfile, VehicleState, ECUOperation, ECUState, ExploiterState
)
from mazda_memory_map import MazdaMemoryMap, MemoryRange, CalibrationTable
from base_exploiter import BaseExploiter, OperationResult, ExploiterError
from eeprom_exploiter import EEPROMExploiter


@dataclass
class ECUInfo:
    """ECU identification and status information."""
    vin: str = ""
    ecu_serial: str = ""
    software_version: str = ""
    calibration_version: str = ""
    bootloader_version: str = ""
    hardware_version: str = ""
    state: ECUState = ECUState.OFFLINE
    flash_size: int = 0
    eeprom_size: int = 0
    supported_operations: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "vin": self.vin,
            "ecu_serial": self.ecu_serial,
            "software_version": self.software_version,
            "calibration_version": self.calibration_version,
            "bootloader_version": self.bootloader_version,
            "hardware_version": self.hardware_version,
            "state": self.state.value,
            "flash_size": self.flash_size,
            "eeprom_size": self.eeprom_size,
            "supported_operations": self.supported_operations,
        }


@dataclass
class FlashSession:
    """Flash operation session tracking."""
    session_id: str
    operation_type: ECUOperation
    start_time: float
    estimated_duration: float
    progress: float = 0.0
    current_address: int = 0
    total_bytes: int = 0
    bytes_processed: int = 0
    backup_created: bool = False
    checksum_verified: bool = False
    
    @property
    def elapsed_time(self) -> float:
        """Get elapsed time in seconds."""
        return time.time() - self.start_time
    
    @property
    def eta_seconds(self) -> float:
        """Get estimated time remaining."""
        if self.progress > 0:
            return self.estimated_duration * (1.0 - self.progress) / self.progress
        return self.estimated_duration


class ECUExploiterError(ExploiterError):
    """ECU exploiter specific errors."""
    pass


class ECUCommunicationError(ECUExploiterError):
    """ECU communication failure."""
    pass


class ECUFlashError(ECUExploiterError):
    """ECU flash operation failure."""
    pass


class MazdaECUExploiter(BaseExploiter):
    """
    Main ECU exploitation module for Mazda vehicles.
    Coordinates all sub-exploiters and provides high-level ECU operations.
    """
    
    # ECU-specific command definitions
    ECU_COMMANDS = {
        "READ_VIN": 0x1A,
        "READ_ECU_INFO": 0x1A,
        "RESET_ECU": 0x11,
        "ENTER_BOOTLOADER": 0x85,
        "EXIT_BOOTLOADER": 0x86,
        "FLASH_ERASE": 0x31,
        "FLASH_PROGRAM": 0x3D,
        "FLASH_VERIFY": 0x31,
        "SECURITY_ACCESS": 0x27,
        "TESTER_PRESENT": 0x3E,
        "DIAGNOSTIC_SESSION": 0x10,
    }
    
    # ECU timing parameters
    ECU_TIMING = {
        "reset_delay_ms": 2000,
        "bootloader_enter_ms": 500,
        "flash_sector_erase_ms": 1000,
        "flash_byte_program_ms": 0.05,
        "verification_byte_ms": 0.01,
    }
    
    def __init__(self, config=None):
        """Initialize ECU exploiter."""
        super().__init__("ECU", config)
        
        # Sub-exploiters
        self.eeprom_exploiter: Optional[EEPROMExploiter] = None
        
        # ECU state
        self.ecu_info = ECUInfo()
        self.current_state = ECUState.OFFLINE
        self.flash_sessions: Dict[str, FlashSession] = {}
        
        # Operation tracking
        self.active_operations: Dict[str, Dict[str, Any]] = {}
        self.operation_history: List[Dict[str, Any]] = []
        
        # Safety and validation
        self.safety_checks_enabled = True
        self.backup_required = True
        
        self.logger.info("MazdaECUExploiter initialized")
    
    async def _on_initialize(self) -> None:
        """Initialize ECU-specific components and sub-exploiters."""
        try:
            # Initialize EEPROM exploiter
            self.eeprom_exploiter = EEPROMExploiter(self.config)
            self.eeprom_exploiter.set_obd_service(self.obd_service)
            self.eeprom_exploiter.set_can_engine(self.can_engine)
            
            if self.current_credentials:
                self.eeprom_exploiter.set_credentials(self.current_credentials)
            
            # Initialize EEPROM exploiter
            eeprom_result = await self.eeprom_exploiter.initialize()
            if not eeprom_result.success:
                raise ECUExploiterError(f"EEPROM exploiter init failed: {eeprom_result.error_message}")
            
            # Connect to ECU and identify
            await self._connect_to_ecu()
            await self._identify_ecu()
            
            self.current_state = ECUState.NORMAL
            self.state = ExploiterState.CONNECTED
            
            self.logger.info("ECU exploiter initialized successfully")
            
        except Exception as e:
            self.logger.error(f"ECU initialization failed: {e}")
            raise ECUExploiterError(f"ECU initialization failed: {e}")
    
    async def _on_shutdown(self) -> None:
        """Shutdown ECU-specific components."""
        try:
            # Cancel all active flash sessions
            for session_id in list(self.flash_sessions.keys()):
                await self.cancel_flash_session(session_id)
            
            # Shutdown EEPROM exploiter
            if self.eeprom_exploiter:
                await self.eeprom_exploiter.shutdown()
            
            self.current_state = ECUState.OFFLINE
            self.logger.info("ECU exploiter shutdown completed")
            
        except Exception as e:
            self.logger.warning(f"ECU shutdown warning: {e}")
    
    async def _connect_to_ecu(self) -> None:
        """Establish communication with ECU."""
        try:
            # Start diagnostic session
            response = await self._send_ecu_command(
                self.ECU_COMMANDS["DIAGNOSTIC_SESSION"],
                bytes([0x01])  # Default diagnostic session
            )
            
            # Send tester present to keep session alive
            await self._send_ecu_command(
                self.ECU_COMMANDS["TESTER_PRESENT"],
                bytes([0x00])
            )
            
            self.logger.info("ECU communication established")
            
        except Exception as e:
            raise ECUCommunicationError(f"Failed to connect to ECU: {e}")
    
    async def _identify_ecu(self) -> None:
        """Identify ECU and gather information."""
        try:
            # Read VIN
            vin_result = await self.read_vin()
            if vin_result.success:
                self.ecu_info.vin = vin_result.data
            
            # Read ECU information
            info_result = await self.get_ecu_info()
            if info_result.success:
                info_data = info_result.data
                self.ecu_info.ecu_serial = info_data.get("serial", "")
                self.ecu_info.software_version = info_data.get("software_version", "")
                self.ecu_info.calibration_version = info_data.get("calibration_version", "")
                self.ecu_info.hardware_version = info_data.get("hardware_version", "")
                self.ecu_info.flash_size = info_data.get("flash_size", 0)
                self.ecu_info.eeprom_size = info_data.get("eeprom_size", 0)
            
            # Set supported operations based on capabilities
            self.ecu_info.supported_operations = [
                "read_memory", "write_memory", "flash_calibration",
                "read_dtc", "clear_dtc", "backup_ecu", "restore_ecu",
                "read_vin", "get_info", "reset_ecu"
            ]
            
            self.logger.info(f"ECU identified: VIN={self.ecu_info.vin}, SW={self.ecu_info.software_version}")
            
        except Exception as e:
            self.logger.warning(f"ECU identification incomplete: {e}")
    
    async def _send_ecu_command(self, service_id: int, data: bytes) -> OBDPacket:
        """
        Send ECU-specific command via OBD.
        
        Args:
            service_id: ECU service ID
            data: Command data
            
        Returns:
            OBD response packet
        """
        # Build command packet
        command_data = bytes([service_id]) + data
        
        # Send via OBD service
        response = await self._send_obd_command(
            mode=None,  # Direct service mode
            pid="",
            data=command_data
        )
        
        # Check for positive response
        if len(response.data) > 0 and response.data[0] == service_id + 0x40:
            return response
        
        # Check for negative response
        if (len(response.data) >= 2 and 
            response.data[0] == 0x7F and 
            response.data[1] == service_id):
            error_code = response.data[2] if len(response.data) > 2 else 0x00
            raise ECUCommunicationError(f"ECU command rejected with error code: 0x{error_code:02X}")
        
        raise ECUCommunicationError("Invalid ECU response format")
    
    async def read_memory(self, address: int, size: int,
                         credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Read data from ECU memory.
        
        Args:
            address: Starting memory address
            size: Number of bytes to read
            credentials: Security credentials
            
        Returns:
            OperationResult with read data
        """
        if credentials:
            self.set_credentials(credentials)
        
        # Validate security and access
        self._validate_security(SecurityLevel.READ_ONLY, "read ECU memory")
        self._validate_memory_access(address, size, write_access=False)
        
        # Route to appropriate memory region
        memory_region = self.memory_map.get_region(address)
        if not memory_region:
            raise ECUExploiterError(f"Unknown memory region: 0x{address:06X}")
        
        if memory_region.region_type.value in ["eeprom", "calibration"]:
            # Use EEPROM exploiter for these regions
            return await self.eeprom_exploiter.read_eeprom(address, size)
        else:
            # Use direct ECU memory read
            operation = lambda: self._read_memory_direct(address, size)
            return await self._execute_with_retry(
                operation, "read_memory", address, size
            )
    
    async def _read_memory_direct(self, address: int, size: int) -> bytes:
        """Direct ECU memory read implementation."""
        data = bytearray()
        remaining = size
        current_address = address
        
        # Read in blocks
        while remaining > 0:
            block_size = min(remaining, self.config.chunk_size)
            
            response = await self._send_ecu_command(
                0x23,  # Read memory by address
                struct.pack("<IH", current_address, block_size)
            )
            
            # Extract data
            if len(response.data) < 3:
                raise ECUExploiterError("Invalid memory read response")
            
            block_data = response.data[3:]  # Skip service, length, address
            if len(block_data) != block_size:
                raise ECUExploiterError(f"Read size mismatch: expected {block_size}, got {len(block_data)}")
            
            data.extend(block_data)
            current_address += block_size
            remaining -= block_size
            
            await asyncio.sleep(0.001)  # Small delay
        
        return bytes(data)
    
    async def write_memory(self, address: int, data: bytes,
                          credentials: Optional[SecurityCredentials] = None,
                          verify: bool = True) -> OperationResult:
        """
        Write data to ECU memory.
        
        Args:
            address: Starting memory address
            data: Data to write
            credentials: Security credentials
            verify: Whether to verify write after completion
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        size = len(data)
        
        # Validate security and access
        self._validate_security(SecurityLevel.TUNING, "write ECU memory")
        self._validate_memory_access(address, size, write_access=True)
        
        # Route to appropriate memory region
        memory_region = self.memory_map.get_region(address)
        if not memory_region:
            raise ECUExploiterError(f"Unknown memory region: 0x{address:06X}")
        
        if memory_region.region_type.value in ["eeprom", "calibration"]:
            # Use EEPROM exploiter for these regions
            return await self.eeprom_exploiter.write_eeprom(address, data, verify=verify)
        else:
            # Use direct ECU memory write
            operation = lambda: self._write_memory_direct(address, data, verify)
            return await self._execute_with_retry(
                operation, "write_memory", address, data, verify
            )
    
    async def _write_memory_direct(self, address: int, data: bytes, verify: bool) -> bool:
        """Direct ECU memory write implementation."""
        # Request download
        await self._send_ecu_command(
            0x34,  # Request download
            struct.pack("<IH", address, len(data))
        )
        
        # Transfer data in blocks
        offset = 0
        block_number = 0
        
        while offset < len(data):
            block_size = min(len(data) - offset, self.config.chunk_size)
            block_data = data[offset:offset + block_size]
            
            transfer_data = bytes([block_number]) + block_data
            
            await self._send_ecu_command(
                0x36,  # Transfer data
                transfer_data
            )
            
            offset += block_size
            block_number += 1
            
            # Programming delay
            await asyncio.sleep(self.ECU_TIMING["flash_byte_program_ms"] * block_size / 1000.0)
        
        # Transfer exit
        await self._send_ecu_command(
            0x37,  # Transfer exit
            bytes()
        )
        
        # Verify if requested
        if verify:
            read_data = await self._read_memory_direct(address, len(data))
            if read_data != data:
                raise ECUFlashError("Write verification failed: data mismatch")
        
        return True
    
    async def read_vin(self, credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Read Vehicle Identification Number.
        
        Args:
            credentials: Security credentials
            
        Returns:
            OperationResult with VIN
        """
        if credentials:
            self.set_credentials(credentials)
        
        self._validate_security(SecurityLevel.READ_ONLY, "read VIN")
        
        try:
            # Use OBD service to read VIN (more reliable)
            vin = await self.obd_service.get_vin(self.current_credentials)
            
            return OperationResult(
                success=True,
                operation_id="read_vin",
                data=vin
            )
            
        except Exception as e:
            # Fallback to direct ECU command
            try:
                response = await self._send_ecu_command(
                    self.ECU_COMMANDS["READ_VIN"],
                    bytes([0x90])  # VIN identifier
                )
                
                vin_data = response.data[3:]  # Skip service, length, identifier
                vin = vin_data.decode('ascii', errors='ignore').strip()
                
                return OperationResult(
                    success=True,
                    operation_id="read_vin",
                    data=vin
                )
                
            except Exception as fallback_error:
                raise ECUExploiterError(f"Failed to read VIN: {e}, fallback: {fallback_error}")
    
    async def get_ecu_info(self, credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Get ECU identification and status information.
        
        Args:
            credentials: Security credentials
            
        Returns:
            OperationResult with ECU info
        """
        if credentials:
            self.set_credentials(credentials)
        
        self._validate_security(SecurityLevel.READ_ONLY, "get ECU info")
        
        try:
            info = {}
            
            # Read ECU serial number
            try:
                response = await self._send_ecu_command(
                    self.ECU_COMMANDS["READ_ECU_INFO"],
                    bytes([0x86])  # ECU serial identifier
                )
                serial_data = response.data[3:]
                info["serial"] = serial_data.decode('ascii', errors='ignore').strip()
            except Exception:
                info["serial"] = ""
            
            # Read software version
            try:
                response = await self._send_ecu_command(
                    self.ECU_COMMANDS["READ_ECU_INFO"],
                    bytes([0x87])  # Software version identifier
                )
                sw_data = response.data[3:]
                info["software_version"] = sw_data.decode('ascii', errors='ignore').strip()
            except Exception:
                info["software_version"] = ""
            
            # Read calibration version
            try:
                response = await self._send_ecu_command(
                    self.ECU_COMMANDS["READ_ECU_INFO"],
                    bytes([0x88])  # Calibration version identifier
                )
                cal_data = response.data[3:]
                info["calibration_version"] = cal_data.decode('ascii', errors='ignore').strip()
            except Exception:
                info["calibration_version"] = ""
            
            # Read hardware version
            try:
                response = await self._send_ecu_command(
                    self.ECU_COMMANDS["READ_ECU_INFO"],
                    bytes([0x89])  # Hardware version identifier
                )
                hw_data = response.data[3:]
                info["hardware_version"] = hw_data.decode('ascii', errors='ignore').strip()
            except Exception:
                info["hardware_version"] = ""
            
            # Get memory sizes from memory map
            info["flash_size"] = 2 * 1024 * 1024  # 2MB typical
            info["eeprom_size"] = 64 * 1024       # 64KB typical
            
            return OperationResult(
                success=True,
                operation_id="get_ecu_info",
                data=info
            )
            
        except Exception as e:
            raise ECUExploiterError(f"Failed to get ECU info: {e}")
    
    async def backup_ecu(self, include_calibration: bool = True,
                        include_eeprom: bool = True,
                        credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Create complete ECU backup.
        
        Args:
            include_calibration: Include calibration data
            include_eeprom: Include EEPROM data
            credentials: Security credentials
            
        Returns:
            OperationResult with backup data
        """
        if credentials:
            self.set_credentials(credentials)
        
        self._validate_security(SecurityLevel.DIAGNOSTIC, "backup ECU")
        
        backup_data = {}
        backup_id = f"ecu_backup_{int(time.time())}"
        
        try:
            # Backup calibration region
            if include_calibration:
                cal_region = self.memory_map.get_region_by_name("CALIBRATION_MAIN")
                if cal_region:
                    cal_result = await self.read_memory(
                        cal_region.start_address, 
                        cal_region.size
                    )
                    if cal_result.success:
                        backup_data["calibration"] = {
                            "address": cal_region.start_address,
                            "size": cal_region.size,
                            "data": cal_result.data,
                            "checksum": self.memory_map.calculate_checksum(cal_result.data),
                        }
            
            # Backup EEPROM
            if include_eeprom and self.eeprom_exploiter:
                eeprom_result = await self.eeprom_exploiter.backup_eeprom()
                if eeprom_result.success:
                    backup_data["eeprom"] = eeprom_result.data
            
            # Add metadata
            backup_data["metadata"] = {
                "backup_id": backup_id,
                "timestamp": time.time(),
                "vin": self.ecu_info.vin,
                "ecu_info": self.ecu_info.to_dict(),
                "backup_type": "full" if include_calibration and include_eeprom else "partial",
            }
            
            self.logger.info(f"ECU backup created: {backup_id}")
            
            return OperationResult(
                success=True,
                operation_id="backup_ecu",
                data=backup_data
            )
            
        except Exception as e:
            raise ECUExploiterError(f"ECU backup failed: {e}")
    
    async def restore_ecu(self, backup_data: Dict[str, Any],
                         verify: bool = True,
                         credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Restore ECU from backup.
        
        Args:
            backup_data: Backup data dictionary
            verify: Whether to verify restore
            credentials: Security credentials
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        self._validate_security(SecurityLevel.FLASH, "restore ECU")
        
        try:
            # Validate backup
            if "metadata" not in backup_data:
                raise ECUExploiterError("Invalid backup: missing metadata")
            
            metadata = backup_data["metadata"]
            backup_id = metadata.get("backup_id", "unknown")
            
            self.logger.info(f"Starting ECU restore: {backup_id}")
            
            # Restore calibration if present
            if "calibration" in backup_data:
                cal_data = backup_data["calibration"]
                write_result = await self.write_memory(
                    cal_data["address"],
                    cal_data["data"],
                    verify=verify
                )
                if not write_result.success:
                    raise ECUExploiterError(f"Calibration restore failed: {write_result.error_message}")
            
            # Restore EEPROM if present
            if "eeprom" in backup_data and self.eeprom_exploiter:
                eeprom_data = backup_data["eeprom"]
                if "backup_key" in eeprom_data:
                    restore_result = await self.eeprom_exploiter.restore_eeprom(
                        eeprom_data["backup_key"]
                    )
                    if not restore_result.success:
                        raise ECUExploiterError(f"EEPROM restore failed: {restore_result.error_message}")
            
            self.logger.info(f"ECU restore completed: {backup_id}")
            
            return OperationResult(
                success=True,
                operation_id="restore_ecu",
                data={"backup_id": backup_id, "verified": verify}
            )
            
        except Exception as e:
            raise ECUExploiterError(f"ECU restore failed: {e}")
    
    async def reset_ecu(self, credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Reset ECU.
        
        Args:
            credentials: Security credentials
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        self._validate_security(SecurityLevel.DIAGNOSTIC, "reset ECU")
        
        try:
            # Send ECU reset command
            await self._send_ecu_command(
                self.ECU_COMMANDS["RESET_ECU"],
                bytes([0x01])  # Hard reset
            )
            
            # Wait for reset to complete
            await asyncio.sleep(self.ECU_TIMING["reset_delay_ms"] / 1000.0)
            
            # Reconnect and re-identify
            await self._connect_to_ecu()
            await self._identify_ecu()
            
            self.logger.info("ECU reset completed")
            
            return OperationResult(
                success=True,
                operation_id="reset_ecu",
                data={"state": self.current_state.value}
            )
            
        except Exception as e:
            raise ECUExploiterError(f"ECU reset failed: {e}")
    
    async def enter_bootloader(self, credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Enter bootloader mode for flash operations.
        
        Args:
            credentials: Security credentials
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        self._validate_security(SecurityLevel.FLASH, "enter bootloader")
        
        try:
            # Send bootloader enter command
            await self._send_ecu_command(
                self.ECU_COMMANDS["ENTER_BOOTLOADER"],
                bytes([0x01])  # Enter bootloader
            )
            
            # Wait for bootloader to initialize
            await asyncio.sleep(self.ECU_TIMING["bootloader_enter_ms"] / 1000.0)
            
            self.current_state = ECUState.BOOTLOADER
            
            self.logger.info("ECU entered bootloader mode")
            
            return OperationResult(
                success=True,
                operation_id="enter_bootloader",
                data={"state": self.current_state.value}
            )
            
        except Exception as e:
            raise ECUExploiterError(f"Failed to enter bootloader: {e}")
    
    async def exit_bootloader(self, credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Exit bootloader mode and return to normal operation.
        
        Args:
            credentials: Security credentials
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        self._validate_security(SecurityLevel.FLASH, "exit bootloader")
        
        try:
            # Send bootloader exit command
            await self._send_ecu_command(
                self.ECU_COMMANDS["EXIT_BOOTLOADER"],
                bytes([0x01])  # Exit bootloader
            )
            
            # Wait for normal mode to initialize
            await asyncio.sleep(1.0)
            
            # Reconnect in normal mode
            await self._connect_to_ecu()
            self.current_state = ECUState.NORMAL
            
            self.logger.info("ECU exited bootloader mode")
            
            return OperationResult(
                success=True,
                operation_id="exit_bootloader",
                data={"state": self.current_state.value}
            )
            
        except Exception as e:
            raise ECUExploiterError(f"Failed to exit bootloader: {e}")
    
    async def start_flash_session(self, operation_type: ECUOperation,
                                address: int, size: int) -> str:
        """
        Start a flash operation session.
        
        Args:
            operation_type: Type of flash operation
            address: Starting address
            size: Size of operation
            
        Returns:
            Session ID
        """
        session_id = f"flash_{operation_type.value}_{int(time.time())}"
        
        session = FlashSession(
            session_id=session_id,
            operation_type=operation_type,
            start_time=time.time(),
            estimated_duration=self._estimate_flash_time(operation_type, size),
            current_address=address,
            total_bytes=size
        )
        
        self.flash_sessions[session_id] = session
        
        self.logger.info(f"Flash session started: {session_id}")
        
        return session_id
    
    async def update_flash_session(self, session_id: str, 
                                 bytes_processed: int) -> None:
        """
        Update flash session progress.
        
        Args:
            session_id: Session identifier
            bytes_processed: Number of bytes processed
        """
        if session_id in self.flash_sessions:
            session = self.flash_sessions[session_id]
            session.bytes_processed = bytes_processed
            session.progress = bytes_processed / max(session.total_bytes, 1)
    
    async def cancel_flash_session(self, session_id: str) -> bool:
        """
        Cancel active flash session.
        
        Args:
            session_id: Session identifier
            
        Returns:
            True if cancelled successfully
        """
        if session_id in self.flash_sessions:
            del self.flash_sessions[session_id]
            self.logger.info(f"Flash session cancelled: {session_id}")
            return True
        return False
    
    def _estimate_flash_time(self, operation_type: ECUOperation, size: int) -> float:
        """Estimate flash operation time."""
        if operation_type == ECUOperation.FLASH_CALIBRATION:
            # Rough estimate: erase + program + verify
            erase_time = (size / 4096) * self.ECU_TIMING["flash_sector_erase_ms"]
            program_time = size * self.ECU_TIMING["flash_byte_program_ms"]
            verify_time = size * self.ECU_TIMING["verification_byte_ms"]
            return (erase_time + program_time + verify_time) / 1000.0
        
        return 60.0  # Default 1 minute
    
    def get_flash_sessions(self) -> Dict[str, FlashSession]:
        """Get all active flash sessions."""
        return self.flash_sessions.copy()
    
    def get_ecu_status(self) -> Dict[str, Any]:
        """Get current ECU status."""
        return {
            "state": self.current_state.value,
            "ecu_info": self.ecu_info.to_dict(),
            "flash_sessions": len(self.flash_sessions),
            "active_operations": len(self.active_operations),
            "safety_checks": self.safety_checks_enabled,
            "backup_required": self.backup_required,
        }
    
    def __del__(self):
        """Cleanup on deletion."""
        if hasattr(self, 'flash_sessions'):
            self.flash_sessions.clear()
        if hasattr(self, 'active_operations'):
            self.active_operations.clear()
