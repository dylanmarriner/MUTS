"""
EEPROMExploiter - EEPROM memory access and flash operations for Mazda ECU.
Provides low-level EEPROM reading, writing, and flash programming capabilities.
Handles backup/restore, checksum validation, and safety-critical operations.
"""

import asyncio
import struct
import hashlib
import time
from typing import Dict, List, Optional, Tuple, Any, Union, BinaryIO
from dataclasses import dataclass, field
from enum import Enum
import io

from models import (
    SecurityLevel, SecurityCredentials, FlashOperation, FlashState,
    LogEntry, CANMessage, OBDPacket, EEPROMOperation, ExploiterState
)
from mazda_memory_map import MazdaMemoryMap, MemoryRange, FlashSector
from base_exploiter import BaseExploiter, OperationResult, ExploiterError, CommunicationError


class EEPROMError(ExploiterError):
    """EEPROM-specific errors."""
    pass


class EEPROMAccessError(EEPROMError):
    """EEPROM access denied."""
    pass


class EEPROMChecksumError(EEPROMError):
    """EEPROM checksum validation failed."""
    pass


class EEPROMExploiter(BaseExploiter):
    """
    EEPROM exploitation module for Mazda ECU.
    Handles EEPROM reading, writing, flash programming, and backup operations.
    """
    
    # EEPROM-specific command definitions
    EEPROM_COMMANDS = {
        "READ_MEMORY": 0x23,
        "WRITE_MEMORY": 0x3D,
        "ERASE_MEMORY": 0x3E,
        "CHECKSUM_MEMORY": 0x31,
        "REQUEST_DOWNLOAD": 0x34,
        "TRANSFER_DATA": 0x36,
        "TRANSFER_EXIT": 0x37,
        "READ_DTC": 0x19,
        "CLEAR_DTC": 0x19,
    }
    
    # EEPROM access timing (typical values)
    EEPROM_TIMING = {
        "read_byte_ms": 0.1,
        "write_byte_ms": 5.0,
        "erase_sector_ms": 1000.0,
        "program_block_ms": 10.0,
        "verify_byte_ms": 0.1,
    }
    
    # EEPROM size limits
    EEPROM_MAX_SIZE = 64 * 1024  # 64KB typical
    BLOCK_SIZE = 1024  # 1KB blocks for transfers
    
    def __init__(self, config=None):
        """Initialize EEPROM exploiter."""
        super().__init__("EEPROM", config)
        
        # EEPROM-specific state
        self.eeprom_connected = False
        self.current_mode = EEPROMMode.BYTE
        self.active_regions: Dict[str, EEPROMRegion] = {}
        self.backup_data: Dict[int, bytes] = {}
        
        # Flash operation tracking
        self.flash_operations: Dict[str, FlashOperation] = {}
        
        # EEPROM configuration
        self.eeprom_size = self.EEPROM_MAX_SIZE
        self.sector_size = 4096  # 4KB sectors
        
        self.logger.info("EEPROMExploiter initialized")
    
    async def _on_initialize(self) -> None:
        """Initialize EEPROM-specific components."""
        try:
            # Test EEPROM connectivity
            await self._test_eeprom_connectivity()
            
            # Get EEPROM size and configuration
            await self._identify_eeprom()
            
            self.eeprom_connected = True
            self.state = ExploiterState.CONNECTED
            
            self.logger.info("EEPROM initialized successfully")
            
        except Exception as e:
            self.logger.error(f"EEPROM initialization failed: {e}")
            raise EEPROMError(f"EEPROM initialization failed: {e}")
    
    async def _on_shutdown(self) -> None:
        """Shutdown EEPROM-specific components."""
        try:
            # Clean up any active operations
            for operation_id in list(self.flash_operations.keys()):
                await self.cancel_flash_operation(operation_id)
            
            self.eeprom_connected = False
            self.logger.info("EEPROM shutdown completed")
            
        except Exception as e:
            self.logger.warning(f"EEPROM shutdown warning: {e}")
    
    async def _test_eeprom_connectivity(self) -> bool:
        """
        Test basic EEPROM connectivity.
        
        Returns:
            True if EEPROM responds correctly
        """
        try:
            # Send a simple read command to test connectivity
            response = await self._send_eeprom_command(
                self.EEPROM_COMMANDS["READ_MEMORY"],
                struct.pack("<IH", 0x000000, 1)  # Read 1 byte from address 0
            )
            
            # Check response format
            if len(response.data) >= 3:
                return True
            
            raise EEPROMError("Invalid EEPROM response during connectivity test")
            
        except Exception as e:
            raise EEPROMError(f"EEPROM connectivity test failed: {e}")
    
    async def _identify_eeprom(self) -> None:
        """Identify EEPROM type and size."""
        try:
            # Try to read EEPROM identifier
            response = await self._send_eeprom_command(
                0x1A,  # Read identifier command
                bytes([0x81])  # EEPROM identifier sub-function
            )
            
            if len(response.data) >= 6:
                # Parse EEPROM information
                # This is a simplified implementation
                # Real implementation would parse specific EEPROM ID bytes
                self.logger.info("EEPROM identified successfully")
            else:
                self.logger.warning("Could not identify EEPROM type, using defaults")
                
        except Exception as e:
            self.logger.warning(f"EEPROM identification failed: {e}, using defaults")
    
    async def _send_eeprom_command(self, service_id: int, 
                                 data: bytes) -> OBDPacket:
        """
        Send EEPROM-specific command via OBD.
        
        Args:
            service_id: EEPROM service ID
            data: Command data
            
        Returns:
            OBD response packet
        """
        # Build command packet
        command_data = bytes([service_id]) + data
        
        # Send via OBD service
        response = await self._send_obd_command(
            mode=None,  # Direct service mode
            pid="",
            data=command_data
        )
        
        # Check for positive response
        if len(response.data) > 0 and response.data[0] == service_id + 0x40:
            return response
        
        # Check for negative response
        if (len(response.data) >= 2 and 
            response.data[0] == 0x7F and 
            response.data[1] == service_id):
            error_code = response.data[2] if len(response.data) > 2 else 0x00
            raise EEPROMError(f"EEPROM command rejected with error code: 0x{error_code:02X}")
        
        raise EEPROMError("Invalid EEPROM response format")
    
    async def read_eeprom(self, address: int, size: int,
                         credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Read data from EEPROM.
        
        Args:
            address: Starting address
            size: Number of bytes to read
            credentials: Security credentials
            
        Returns:
            OperationResult with read data
        """
        if credentials:
            self.set_credentials(credentials)
        
        # Validate security and access
        self._validate_security(SecurityLevel.READ_ONLY, "read EEPROM")
        self._validate_memory_access(address, size, write_access=False)
        
        # Check EEPROM bounds
        if address + size > self.eeprom_size:
            raise EEPROMError(f"Read exceeds EEPROM size: 0x{address:06X}+{size}")
        
        operation = lambda: self._read_eeprom_internal(address, size)
        return await self._execute_with_retry(
            operation, "read_eeprom", address, size
        )
    
    async def _read_eeprom_internal(self, address: int, size: int) -> bytes:
        """Internal EEPROM read implementation."""
        data = bytearray()
        remaining = size
        current_address = address
        
        # Read in blocks to handle large transfers
        while remaining > 0:
            block_size = min(remaining, self.BLOCK_SIZE)
            
            # Send read command
            response = await self._send_eeprom_command(
                self.EEPROM_COMMANDS["READ_MEMORY"],
                struct.pack("<IH", current_address, block_size)
            )
            
            # Extract data from response
            if len(response.data) < 3:
                raise EEPROMError("Invalid read response format")
            
            block_data = response.data[3:]  # Skip service, length, address
            if len(block_data) != block_size:
                raise EEPROMError(f"Read size mismatch: expected {block_size}, got {len(block_data)}")
            
            data.extend(block_data)
            current_address += block_size
            remaining -= block_size
            
            # Small delay between blocks
            await asyncio.sleep(0.01)
        
        return bytes(data)
    
    async def write_eeprom(self, address: int, data: bytes,
                          credentials: Optional[SecurityCredentials] = None,
                          verify: bool = True) -> OperationResult:
        """
        Write data to EEPROM.
        
        Args:
            address: Starting address
            data: Data to write
            credentials: Security credentials
            verify: Whether to verify write after completion
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        size = len(data)
        
        # Validate security and access
        self._validate_security(SecurityLevel.TUNING, "write EEPROM")
        self._validate_memory_access(address, size, write_access=True)
        
        # Check EEPROM bounds
        if address + size > self.eeprom_size:
            raise EEPROMError(f"Write exceeds EEPROM size: 0x{address:06X}+{size}")
        
        # Create backup if required
        if self.config.require_backup:
            await self._create_backup(address, size)
        
        operation = lambda: self._write_eeprom_internal(address, data, verify)
        return await self._execute_with_retry(
            operation, "write_eeprom", address, data, verify
        )
    
    async def _write_eeprom_internal(self, address: int, data: bytes, 
                                   verify: bool) -> bool:
        """Internal EEPROM write implementation."""
        # Request download
        await self._send_eeprom_command(
            self.EEPROM_COMMANDS["REQUEST_DOWNLOAD"],
            struct.pack("<IH", address, len(data))
        )
        
        # Transfer data in blocks
        offset = 0
        block_number = 0
        
        while offset < len(data):
            block_size = min(len(data) - offset, self.BLOCK_SIZE)
            block_data = data[offset:offset + block_size]
            
            # Build transfer data packet
            transfer_data = bytes([block_number]) + block_data
            
            await self._send_eeprom_command(
                self.EEPROM_COMMANDS["TRANSFER_DATA"],
                transfer_data
            )
            
            offset += block_size
            block_number += 1
            
            # Delay for EEPROM programming
            await asyncio.sleep(self.EEPROM_TIMING["write_byte_ms"] * block_size / 1000.0)
        
        # Transfer exit
        await self._send_eeprom_command(
            self.EEPROM_COMMANDS["TRANSFER_EXIT"],
            bytes()
        )
        
        # Verify if requested
        if verify:
            await self._verify_write(address, data)
        
        return True
    
    async def _verify_write(self, address: int, expected_data: bytes) -> None:
        """Verify that data was written correctly."""
        read_data = await self._read_eeprom_internal(address, len(expected_data))
        
        if read_data != expected_data:
            raise EEPROMChecksumError("Write verification failed: data mismatch")
    
    async def erase_eeprom(self, address: int, size: int,
                          credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Erase EEPROM region.
        
        Args:
            address: Starting address
            size: Size to erase
            credentials: Security credentials
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        # Validate security and access
        self._validate_security(SecurityLevel.FLASH, "erase EEPROM")
        self._validate_memory_access(address, size, write_access=True)
        
        operation = lambda: self._erase_eeprom_internal(address, size)
        return await self._execute_with_retry(
            operation, "erase_eeprom", address, size
        )
    
    async def _erase_eeprom_internal(self, address: int, size: int) -> bool:
        """Internal EEPROM erase implementation."""
        # Align to sector boundaries
        sector_start = (address // self.sector_size) * self.sector_size
        sector_end = ((address + size + self.sector_size - 1) // self.sector_size) * self.sector_size
        
        current_address = sector_start
        
        while current_address < sector_end:
            await self._send_eeprom_command(
                self.EEPROM_COMMANDS["ERASE_MEMORY"],
                struct.pack("<IH", current_address, self.sector_size)
            )
            
            # Wait for erase to complete
            await asyncio.sleep(self.EEPROM_TIMING["erase_sector_ms"] / 1000.0)
            
            current_address += self.sector_size
        
        return True
    
    async def backup_eeprom(self, address: int = 0, size: Optional[int] = None,
                           credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Create backup of EEPROM region.
        
        Args:
            address: Starting address (default 0)
            size: Size to backup (default entire EEPROM)
            credentials: Security credentials
            
        Returns:
            OperationResult with backup data
        """
        if credentials:
            self.set_credentials(credentials)
        
        if size is None:
            size = self.eeprom_size
        
        # Validate security
        self._validate_security(SecurityLevel.DIAGNOSTIC, "backup EEPROM")
        
        # Read EEPROM data
        read_result = await self.read_eeprom(address, size)
        if not read_result.success:
            return read_result
        
        backup_data = read_result.data
        
        # Store backup
        backup_key = hash((address, size, time.time()))
        self.backup_data[backup_key] = backup_data
        
        # Calculate checksum
        checksum = hashlib.sha256(backup_data).hexdigest()
        
        self.logger.info(f"EEPROM backup created: 0x{address:06X}+{size}, checksum: {checksum[:16]}")
        
        return OperationResult(
            success=True,
            operation_id=read_result.operation_id,
            data={
                "backup_key": backup_key,
                "data": backup_data,
                "checksum": checksum,
                "address": address,
                "size": size,
            }
        )
    
    async def restore_eeprom(self, backup_key: int, address: Optional[int] = None,
                           credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Restore EEPROM from backup.
        
        Args:
            backup_key: Backup identifier
            address: Restore address (default uses backup's original address)
            credentials: Security credentials
            
        Returns:
            OperationResult indicating success
        """
        if credentials:
            self.set_credentials(credentials)
        
        # Validate security
        self._validate_security(SecurityLevel.FLASH, "restore EEPROM")
        
        # Get backup data
        if backup_key not in self.backup_data:
            raise EEPROMError(f"Backup key not found: {backup_key}")
        
        backup_data = self.backup_data[backup_key]
        
        # Determine restore address
        if address is None:
            # Extract address from backup metadata (simplified)
            address = 0  # Default to start of EEPROM
        
        # Write backup data
        write_result = await self.write_eeprom(address, backup_data, credentials)
        
        if write_result.success:
            self.logger.info(f"EEPROM restored from backup: key {backup_key}, address 0x{address:06X}")
        
        return write_result
    
    async def calculate_checksum(self, address: int, size: int,
                               credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Calculate EEPROM region checksum.
        
        Args:
            address: Starting address
            size: Size to checksum
            credentials: Security credentials
            
        Returns:
            OperationResult with checksum
        """
        if credentials:
            self.set_credentials(credentials)
        
        # Validate security
        self._validate_security(SecurityLevel.READ_ONLY, "calculate checksum")
        
        # Read data
        read_result = await self.read_eeprom(address, size)
        if not read_result.success:
            return read_result
        
        data = read_result.data
        
        # Calculate multiple checksums
        checksums = {
            "crc32": format(struct.unpack('>I', struct.pack('>I', 0xFFFFFFFF))[0] ^ 0xFFFFFFFF, '08X'),
            "sha256": hashlib.sha256(data).hexdigest(),
            "md5": hashlib.md5(data).hexdigest(),
        }
        
        return OperationResult(
            success=True,
            operation_id=read_result.operation_id,
            data=checksums
        )
    
    async def verify_eeprom(self, address: int, expected_data: bytes,
                          credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Verify EEPROM data against expected values.
        
        Args:
            address: Starting address
            expected_data: Expected data bytes
            credentials: Security credentials
            
        Returns:
            OperationResult with verification status
        """
        if credentials:
            self.set_credentials(credentials)
        
        # Validate security
        self._validate_security(SecurityLevel.READ_ONLY, "verify EEPROM")
        
        # Read actual data
        read_result = await self.read_eeprom(address, len(expected_data))
        if not read_result.success:
            return read_result
        
        actual_data = read_result.data
        
        # Compare data
        matches = actual_data == expected_data
        
        if not matches:
            # Find differences
            differences = []
            for i, (expected, actual) in enumerate(zip(expected_data, actual_data)):
                if expected != actual:
                    differences.append({
                        "offset": i,
                        "expected": expected,
                        "actual": actual,
                    })
            
            return OperationResult(
                success=False,
                operation_id=read_result.operation_id,
                error_message=f"Data mismatch at {len(differences)} locations",
                data={
                    "matches": False,
                    "differences": differences[:10],  # Limit to first 10 differences
                }
            )
        
        return OperationResult(
            success=True,
            operation_id=read_result.operation_id,
            data={"matches": True}
        )
    
    async def _create_backup(self, address: int, size: int) -> None:
        """Create automatic backup before write operations."""
        try:
            backup_result = await self.backup_eeprom(address, size)
            if backup_result.success:
                self.logger.debug(f"Automatic backup created for 0x{address:06X}+{size}")
            else:
                self.logger.warning(f"Automatic backup failed: {backup_result.error_message}")
        except Exception as e:
            self.logger.warning(f"Automatic backup error: {e}")
    
    async def start_flash_operation(self, operation_id: str, 
                                  operation_type: EEPROMOperation) -> FlashOperation:
        """
        Start a flash operation with tracking.
        
        Args:
            operation_id: Unique operation identifier
            operation_type: Type of flash operation
            
        Returns:
            FlashOperation object
        """
        operation = self._create_flash_operation(operation_id)
        operation.state = FlashState.PREPARING
        
        self.flash_operations[operation_id] = operation
        
        self.logger.info(f"Flash operation started: {operation_id} ({operation_type.value})")
        
        return operation
    
    async def update_flash_operation(self, operation_id: str, 
                                   progress: float, state: Optional[FlashState] = None,
                                   error_message: Optional[str] = None) -> None:
        """
        Update flash operation progress.
        
        Args:
            operation_id: Operation identifier
            progress: Progress percentage (0-1)
            state: New state (optional)
            error_message: Error message (optional)
        """
        if operation_id in self.flash_operations:
            operation = self.flash_operations[operation_id]
            
            operation.progress = progress
            if state:
                operation.state = state
            if error_message:
                operation.error_message = error_message
    
    async def cancel_flash_operation(self, operation_id: str) -> bool:
        """
        Cancel an active flash operation.
        
        Args:
            operation_id: Operation identifier
            
        Returns:
            True if cancelled successfully
        """
        if operation_id in self.flash_operations:
            operation = self.flash_operations[operation_id]
            operation.state = FlashState.FAILED
            operation.error_message = "Operation cancelled"
            
            del self.flash_operations[operation_id]
            
            self.logger.info(f"Flash operation cancelled: {operation_id}")
            return True
        
        return False
    
    def get_flash_operations(self) -> Dict[str, FlashOperation]:
        """Get all active flash operations."""
        return self.flash_operations.copy()
    
    def get_backup_list(self) -> List[Dict[str, Any]]:
        """Get list of available backups."""
        backups = []
        for key, data in self.backup_data.items():
            backups.append({
                "key": key,
                "size": len(data),
                "checksum": hashlib.sha256(data).hexdigest()[:16],
            })
        return backups
    
    def clear_backups(self) -> int:
        """Clear all backup data."""
        count = len(self.backup_data)
        self.backup_data.clear()
        self.logger.info(f"Cleared {count} EEPROM backups")
        return count
    
    async def get_eeprom_info(self, credentials: Optional[SecurityCredentials] = None) -> OperationResult:
        """
        Get EEPROM information and status.
        
        Args:
            credentials: Security credentials
            
        Returns:
            OperationResult with EEPROM info
        """
        if credentials:
            self.set_credentials(credentials)
        
        # Validate security
        self._validate_security(SecurityLevel.READ_ONLY, "get EEPROM info")
        
        info = {
            "connected": self.eeprom_connected,
            "size": self.eeprom_size,
            "sector_size": self.sector_size,
            "block_size": self.BLOCK_SIZE,
            "mode": self.current_mode.value,
            "backups": len(self.backup_data),
            "active_operations": len(self.flash_operations),
        }
        
        return OperationResult(
            success=True,
            operation_id="eeprom_info",
            data=info
        )
    
    def __del__(self):
        """Cleanup on deletion."""
        if hasattr(self, 'flash_operations'):
            self.flash_operations.clear()
        if hasattr(self, 'backup_data'):
            self.backup_data.clear()
