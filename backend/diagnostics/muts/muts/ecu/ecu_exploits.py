#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MAZDASPEED3_ECU_EXPLOITS.py
ADVANCED ECU EXPLOITATION AND MEMORY PATCHING
"""

import struct
import hashlib
import can
import time
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import threading
import logging

class MemoryAccessType(Enum):
    READ = 0x23
    WRITE = 0x3D
    TESTER_PRESENT = 0x3E

@dataclass
class MemoryPatch:
    """ECU MEMORY PATCH STRUCTURE"""
    address: int
    original_data: bytes
    patched_data: bytes
    description: str
    active: bool = False

class MazdaECUExploit:
    """
    ADVANCED ECU EXPLOITATION ENGINE
    Provides low-level ECU access for tuning and diagnostics
    """
    
    def __init__(self, can_interface: str = 'can0'):
        self.can_interface = can_interface
        self.bus = None
        self.security_level = 0
        self.patches = {}
        self.connected = False
        
        # ECU memory map for Mazdaspeed 3
        self.memory_map = {
            'calibration_start': 0x800000,
            'calibration_end': 0x80FFFF,
            'runtime_data': 0xFF0000,
            'adaptive_data': 0xFFC000,
            'dtc_storage': 0xFFD000,
            'security_keys': 0xFFE000
        }
        
        # Setup logging
        self.logger = logging.getLogger('MazdaECUExploit')
    
    def connect(self) -> bool:
        """CONNECT TO ECU VIA CAN BUS"""
        try:
            self.bus = can.interface.Bus(
                channel=self.can_interface,
                bustype='socketcan'
            )
            self.connected = True
            self.logger.info(f"Connected to CAN bus: {self.can_interface}")
            return True
        except Exception as e:
            self.logger.error(f"CAN connection failed: {e}")
            return False
    
    def disconnect(self):
        """DISCONNECT FROM CAN BUS"""
        if self.bus:
            self.bus.shutdown()
        self.connected = False
    
    def send_diagnostic_request(self, service: int, data: bytes = b'') -> Optional[bytes]:
        """SEND DIAGNOSTIC REQUEST TO ECU"""
        if not self.connected:
            return None
        
        try:
            # Build CAN message
            payload = bytearray([service])
            payload.extend(data)
            
            # Pad to 8 bytes
            while len(payload) < 8:
                payload.append(0x00)
            
            message = can.Message(
                arbitration_id=0x7E0,
                data=payload[:8],
                is_extended_id=False
            )
            
            self.bus.send(message)
            time.sleep(0.05)
            
            # Wait for response
            response = self.bus.recv(timeout=1.0)
            if response and response.arbitration_id == 0x7E8:
                return response.data
            
        except Exception as e:
            self.logger.error(f"Diagnostic request failed: {e}")
        
        return None
    
    def request_security_access(self, level: int = 1) -> Optional[bytes]:
        """REQUEST SECURITY SEED FROM ECU"""
        try:
            response = self.send_diagnostic_request(0x27, bytes([level]))
            
            if response and response[0] == 0x67:
                # Extract seed (bytes 2-5)
                seed = response[2:6]
                self.logger.info(f"Security seed received: {seed.hex()}")
                return seed
            
        except Exception as e:
            self.logger.error(f"Security access request failed: {e}")
        
        return None
    
    def send_security_key(self, level: int, key: bytes) -> bool:
        """SEND SECURITY KEY TO ECU"""
        try:
            response = self.send_diagnostic_request(0x27, bytes([level + 1]) + key)
            
            if response and response[0] == 0x67:
                self.security_level = level
                self.logger.info(f"Security access granted at level {level}")
                return True
            
        except Exception as e:
            self.logger.error(f"Security key send failed: {e}")
        
        return False
    
    def unlock_ecu(self, vin: str = "") -> bool:
        """UNLOCK ECU FOR MEMORY ACCESS"""
        try:
            # Request seed
            seed = self.request_security_access(1)
            if not seed:
                return False
            
            # Calculate key using Mazda algorithm
            key = self._calculate_security_key(seed, vin)
            
            # Send key
            if self.send_security_key(1, key):
                # Request additional access for memory operations
                seed2 = self.request_security_access(2)
                if seed2:
                    key2 = self._calculate_security_key(seed2, vin)
                    return self.send_security_key(2, key2)
            
        except Exception as e:
            self.logger.error(f"ECU unlock failed: {e}")
        
        return False
    
    def _calculate_security_key(self, seed: bytes, vin: str) -> bytes:
        """CALCULATE MAZDA SECURITY KEY FROM SEED"""
        key = bytearray(4)
        
        # Mazda M12R v3.4 algorithm
        for i in range(4):
            temp = seed[i] ^ 0x73
            temp = (temp + i) & 0xFF
            temp = temp ^ 0xA9
            key[i] = (temp + 0x1F) & 0xFF
        
        return bytes(key)
    
    def read_memory(self, address: int, length: int) -> Optional[bytes]:
        """READ ECU MEMORY BY ADDRESS"""
        if self.security_level < 1:
            self.logger.error("Insufficient security level for memory read")
            return None
        
        try:
            # Build read memory request
            payload = bytearray()
            payload.extend(address.to_bytes(3, 'big'))  # 3-byte address
            payload.append(length & 0xFF)  # Length
            
            response = self.send_diagnostic_request(0x23, payload)
            
            if response and response[0] == 0x63:
                # Extract data (skip header and address)
                data_start = 4  # Response ID + service + address(3)
                return response[data_start:data_start + length]
            
        except Exception as e:
            self.logger.error(f"Memory read failed: {e}")
        
        return None
    
    def write_memory(self, address: int, data: bytes) -> bool:
        """WRITE DATA TO ECU MEMORY"""
        if self.security_level < 2:
            self.logger.error("Insufficient security level for memory write")
            return False
        
        try:
            # Build write memory request
            payload = bytearray()
            payload.extend(address.to_bytes(3, 'big'))  # 3-byte address
            payload.extend(data)  # Data to write
            
            response = self.send_diagnostic_request(0x3D, payload)
            
            if response and response[0] == 0x7D:
                self.logger.info(f"Memory write successful: 0x{address:06X}")
                return True
            
        except Exception as e:
            self.logger.error(f"Memory write failed: {e}")
        
        return False
    
    def create_patch(self, address: int, data: bytes, description: str) -> bool:
        """CREATE MEMORY PATCH"""
        try:
            # Read original data
            original = self.read_memory(address, len(data))
            if not original:
                return False
            
            # Create patch
            patch = MemoryPatch(
                address=address,
                original_data=original,
                patched_data=data,
                description=description
            )
            
            self.patches[address] = patch
            self.logger.info(f"Patch created: {description} at 0x{address:06X}")
            return True
            
        except Exception as e:
            self.logger.error(f"Patch creation failed: {e}")
        
        return False
    
    def apply_patch(self, address: int) -> bool:
        """APPLY MEMORY PATCH"""
        if address not in self.patches:
            self.logger.error(f"No patch found for address 0x{address:06X}")
            return False
        
        patch = self.patches[address]
        
        try:
            if self.write_memory(patch.address, patch.patched_data):
                patch.active = True
                self.logger.info(f"Patch applied: {patch.description}")
                return True
            
        except Exception as e:
            self.logger.error(f"Patch application failed: {e}")
        
        return False
    
    def remove_patch(self, address: int) -> bool:
        """REMOVE MEMORY PATCH (RESTORE ORIGINAL)"""
        if address not in self.patches:
            return False
        
        patch = self.patches[address]
        
        try:
            if self.write_memory(patch.address, patch.original_data):
                patch.active = False
                self.logger.info(f"Patch removed: {patch.description}")
                return True
            
        except Exception as e:
            self.logger.error(f"Patch removal failed: {e}")
        
        return False
    
    def apply_all_patches(self) -> bool:
        """APPLY ALL CREATED PATCHES"""
        success = True
        
        for address in self.patches:
            if not self.patches[address].active:
                if not self.apply_patch(address):
                    success = False
        
        return success
    
    def remove_all_patches(self) -> bool:
        """REMOVE ALL ACTIVE PATCHES"""
        success = True
        
        for address in self.patches:
            if self.patches[address].active:
                if not self.remove_patch(address):
                    success = False
        
        return success
    
    def read_calibration(self) -> Optional[Dict]:
        """READ ECU CALIBRATION DATA"""
        try:
            calib_data = {}
            
            # Read calibration ID
            calib_id = self.read_memory(0xFF0000, 16)
            if calib_id:
                calib_data['calibration_id'] = calib_id.decode('ascii', errors='ignore').strip()
            
            # Read software version
            sw_version = self.read_memory(0xFF0010, 8)
            if sw_version:
                calib_data['software_version'] = sw_version.decode('ascii', errors='ignore').strip()
            
            # Read VIN
            vin = self.read_memory(0xFF0020, 17)
            if vin:
                calib_data['vin'] = vin.decode('ascii', errors='ignore').strip()
            
            return calib_data
            
        except Exception as e:
            self.logger.error(f"Calibration read failed: {e}")
        
        return None
    
    def clear_adaptive_data(self) -> bool:
        """CLEAR ECU ADAPTIVE LEARNING DATA"""
        try:
            # Clear fuel trims
            if self.write_memory(0xFFC100, b'\x00' * 512):
                self.logger.info("Fuel trim adaptive data cleared")
            
            # Clear knock learning
            if self.write_memory(0xFFC200, b'\x00' * 256):
                self.logger.info("Knock learning data cleared")
            
            # Clear idle learning
            if self.write_memory(0xFFC300, b'\x00' * 128):
                self.logger.info("Idle learning data cleared")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Adaptive data clear failed: {e}")
        
        return False
    
    def reset_flash_counter(self) -> bool:
        """RESET ECU FLASH COUNTER"""
        try:
            # Flash counter is typically at 0xFFE000
            if self.write_memory(0xFFE000, b'\x00\x00\x00\x00'):
                self.logger.info("Flash counter reset to 0")
                return True
            
        except Exception as e:
            self.logger.error(f"Flash counter reset failed: {e}")
        
        return False
    
    def get_patch_list(self) -> List[Dict]:
        """GET LIST OF ALL PATCHES"""
        patches = []
        
        for address, patch in self.patches.items():
            patches.append({
                'address': f"0x{address:06X}",
                'description': patch.description,
                'active': patch.active,
                'original': patch.original_data.hex(),
                'patched': patch.patched_data.hex()
            })
        
        return patches

# Utility functions
def calculate_checksum(data: bytes) -> int:
    """CALCULATE MAZDA ECU CHECKSUM"""
    checksum = 0
    for byte in data:
        checksum = (checksum + byte) & 0xFFFF
    return checksum

def verify_ecu_response(response: bytes, expected_service: int) -> bool:
    """VERIFY ECU DIAGNOSTIC RESPONSE"""
    if not response or len(response) < 1:
        return False
    
    # Positive response has service ID + 0x40
    return response[0] == expected_service + 0x40

# Demonstration
def demonstrate_ecu_exploits():
    """DEMONSTRATE ECU EXPLOITATION CAPABILITIES"""
    print("MAZDASPEED 3 ECU EXPLOITATION DEMONSTRATION")
    print("=" * 50)
    
    ecu = MazdaECUExploit()
    
    try:
        if ecu.connect():
            print("Connected to ECU")
            
            # Unlock ECU
            if ecu.unlock_ecu():
                print("ECU unlocked successfully")
                
                # Read calibration
                calib = ecu.read_calibration()
                if calib:
                    print(f"Calibration ID: {calib.get('calibration_id', 'Unknown')}")
                    print(f"Software Version: {calib.get('software_version', 'Unknown')}")
                    print(f"VIN: {calib.get('vin', 'Unknown')}")
                
                # Create and apply patches
                boost_patch = bytes([0x12])  # Example boost increase
                if ecu.create_patch(0xFFB000, boost_patch, "Boost target increase"):
                    print("Boost patch created")
                    
                    if ecu.apply_patch(0xFFB000):
                        print("Boost patch applied")
                
                # Show patches
                patches = ecu.get_patch_list()
                print(f"\nActive patches: {len(patches)}")
                for patch in patches:
                    if patch['active']:
                        print(f"  - {patch['description']} at {patch['address']}")
                
                # Remove patches
                ecu.remove_all_patches()
                print("\nAll patches removed")
                
            else:
                print("Failed to unlock ECU")
        else:
            print("Failed to connect to ECU")
            
    finally:
        ecu.disconnect()
        print("\nECU exploitation demonstration complete!")

if __name__ == "__main__":
    demonstrate_ecu_exploits()
